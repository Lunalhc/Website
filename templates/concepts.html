<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cryptography Concepts</title>
    <!-- The fonts I used -->
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Acme&family=Architects+Daughter&family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="\static\concepts.css">
    <link rel="icon" href="/static/key.png" type="image/png">
    <link rel="shortcut icon" href="/static/key.png" type="image/png">

</head>
<body id="concepts-page">
    <div class="container">
        <h1 id="concepts-title">Concept List</h1>
        <div class="concepts-container">

            <!-- A Section -->
            <div class="concept-section">
                <h2 class="section-title">A:</h2>
                <div class="concept-item" data-name="Concept 1">
                    <span class="concept-name">Affine transformation:</span>
                    <span class="concept-description">multiplication by a matrix then addition of a vector.</span>
                </div>
                <div class="concept-item" data-name="Concept 2">
                    <span class="concept-name">AES:</span>
                    <span class="concept-description">a kind of block symmetric cipher.</span>
                </div>
                <div class="concept-item" data-name="Concept 3">
                    <span class="concept-name">AES-Cipher key:</span>
                    <span class="concept-description">a rectangular array of bytes, having 4 row and Nk columns.</span>
                </div>
                <div class="concept-item" data-name="Concept 4">
                    <span class="concept-name">AES-Key expansion:</span>
                    <span class="concept-description">generate a series of round keys from cipher key.</span>
                </div>
                <div class="concept-item" data-name="Concept 5">
                    <span class="concept-name">AES-S-box:</span>
                    <span class="concept-description">nonlinear one-for-one substitution table in key expansion.</span>
                </div>
                <div class="concept-item" data-name="Concept 6">
                    <span class="concept-name">AES-Nk:</span>
                    <span class="concept-description">number of 32-bit words.</span>
                </div>
                <div class="concept-item" data-name="Concept 7">
                    <span class="concept-name">AES-Nb:</span>
                    <span class="concept-description">Number of columns.</span>
                </div>
                <div class="concept-item" data-name="Concept 8">
                    <span class="concept-name">AES-Nr:</span>
                    <span class="concept-description">Number of rounds, a function of Nk and Nb.</span>
                </div>
                <div class="concept-item" data-name="Concept 9">
                    <span class="concept-name">Avalanche property:</span>
                    <span class="concept-description">Change to the input, no matter how small, creates a large and unpredictable change in the output.</span>
                </div>
                <div class="concept-item" data-name="Concept 10">
                    <span class="concept-name">Affine cipher:</span>
                    <span class="concept-description">A special case of shift cipher; defined by P = Z<sub>I</sub>, C = Z<sub>I</sub>, x∈P, y∈C, k = (a,b) ∈Z<sub>I</sub> where I is the number of letters in the alphabet; Encryption e<sub>k</sub>(x) = (a*x + b) mod I = y, decryption d<sub>k</sub>(y) = (a<sup>-1</sup>*(y-b)) mod I = x; K = phi(I) * I.</span>
                </div>
                <div class="concept-item" data-name="Concept 11">
                    <span class="concept-name">AES-CBC mode:</span>
                    <span class="concept-description">cipher block chaining.Uses the xor property; XOR operation is its own inverse, meaning that (A ⊕ B) ⊕ B = A. P’[n] = P[n] ⊕ C[n-1], then apply AES encryption to P′[n]. Every block is dependent on the blocks that came before. Changes to any input block thus affect the output block for all subsequent blocks. Does not affect any preceding blocks.</span>
                </div>
                <div class="concept-item" data-name="Concept 12">
                    <span class="concept-name">ANSI X.923:</span>
                    <span class="concept-description">Another padding method where all appended bytes are 0, except for the last byte, which is the length of the total padding. For example, 3 bytes of padding is \x00\x00\x03.</span>
                </div>
                <div class="concept-item" data-name="Concept 13">
                    <span class="concept-name">AES-CTR mode:</span>
                    <span class="concept-description">Counter mode; behaves like a stream cipher. Does not use AES for encryption or decryption of the data. Uses AES and a counter to generate a key stream that is the same length as the plaintext and then uses XOR to combine them together. To get 16 more bytes of key stream, the mode increases the counter by one and encrypts the updated 16 bytes. It only guarantees confidentiality.</span>
                </div>
                <div class="concept-item" data-name="Concept 14">
                    <span class="concept-name">Asynchronous key stream generator:</span>
                    <span class="concept-description">Uses ciphertext y<sub>i</sub> as feedback term.</span>
                </span>
                </div>
                <div class="concept-item" data-name="Concept 15">
                    <span class="concept-name">A5 cipher:</span>
                    <span class="concept-description">Based on clocked LFSRs, used in mobile applications. Has been broken.</span>
                </div>
                <div class="concept-item" data-name="Concept 16">
                    <span class="concept-name">AES-CMAC mode:</span>
                    <span class="concept-description">Generates a MAC to verify the integrity of the data being transmitted. Approved by NIST for use with AES and Triple-AES. Three processes: sub-key generation, MAC generation, MAC verification.</span>
                </div>
                <div class="concept-item" data-name="Concept 17">
                    <span class="concept-name">AES- CCM mode:</span>
                    <span class="concept-description"> counter with cipher block chaining-message authentication code.Used in systems where all of the data is available prior to its use. Only approved for use with block ciphers with 128-bit block sizes. Accepts a 3-part input: payload, associated information, nonce. Applies CBC mode with IV of 0 to the payload, associated information, and nonce to generate MAC. Then uses CTR mode to encrypt payload and MAC to create ciphertext.</span>
                </div>
            </div>

            <!-- B Section -->
            <div class="concept-section">
                <h2 class="section-title">B:</h2>
                <div class="concept-item" data-name="Concept 1">
                    <span class="concept-name">Blockchain:</span>
                    <span class="concept-description">a “distributed ledger. The system is a ledger because it records information related to transactions between participants. contents are stored across the set of participants and not in any central location.</span>
                </div>
                <div class="concept-item" data-name="Concept 2">
                    <span class="concept-name">Block:</span>
                    <span class="concept-description">Every transaction must be stored in a block. It’s just a collection of data. Each transaction within the block must be digitally signed by the transactor. The overall block structure is protected by a hash. Blocks are copied to the entire set of participants.</span>
                </div>
                <div class="concept-item" data-name="Concept 3">
                    <span class="concept-name">Block ciphers:</span>
                    <span class="concept-description">One type of symmetric-key algorithms. Operate on a block of data. AES is a block cipher.</span>
                </div>
                <div class="concept-item" data-name="Concept 4">
                    <span class="concept-name">Block reward:</span>
                    <span class="concept-description">Given to the block creator (miner). No sender/signature. Added to total supply. The longest chain will be trusted.</span>
                </div>
                <div class="concept-item" data-name="Concept 5">
                    <span class="concept-name">Binary extended Euclidean algorithm:</span>
                    <span class="concept-description">Implemented by a right-shift of the data by n bit positions when dividing by 2<sup>n</sup>. Can be used to compute gcd(r<sub>1</sub>,r<sub>0</sub>) and the inverse of r<sub>1</sub> if it exists.</span>
                </div>
            </div>

            <!-- C Section -->
            <div class="concept-section">
                <h2 class="section-title">C:</h2>
                <div class="concept-item" data-name="Concept 1">
                    <span class="concept-name">Collision resistance:</span>
                    <span class="concept-description">It’s hard to find any two inputs that produce the same output.</span>
                </div>
                <div class="concept-item" data-name="Concept 2">
                    <span class="concept-name">Candidate Block:</span>
                    <span class="concept-description">The miners take some set of requested transactions (there is a limited number per block) and create a candidate block. This block isn't the next block in the blockchain until the miner can solve a cryptographic puzzle to find a special kind of SHA-256 hash value.</span>
                </div>
                <div class="concept-item" data-name="Concept 3">
                    <span class="concept-name">Ciphertext-only attack:</span>
                    <span class="concept-description">Attacker knows the ciphertexts y<sub>1</sub> = ek(x<sub>1</sub>), y<sub>2</sub> = ek(x<sub>2</sub>),…, and wants to know the plaintexts x<sub>1</sub>, x<sub>2</sub>,… or the key k.</span>
                </div>
                <div class="concept-item" data-name="Concept 4">
                    <span class="concept-name">Chosen-Plaintext attack:</span>
                    <span class="concept-description">Attacker knows some plaintext-ciphertext pairs (x<sub>1</sub>, y<sub>1</sub> = ek(x<sub>1</sub>)), (x<sub>2</sub>, y<sub>2</sub> = ek(x<sub>2</sub>)),…, and is able to choose x<sub>1</sub>, x<sub>2</sub>,… wants to know the key k.</span>
                </div>
                <div class="concept-item" data-name="Concept 5">
                    <span class="concept-name">Chosen-Ciphertext attack:</span>
                    <span class="concept-description">Attacker knows some plaintext-ciphertext pairs (x<sub>1</sub>, y<sub>1</sub> = ek(x<sub>1</sub>)), (x<sub>2</sub>, y<sub>2</sub> = ek(x<sub>2</sub>)),…, and is able to choose y<sub>1</sub>, y<sub>2</sub>,… wants to know the key k.</span>
                </div>
                <div class="concept-item" data-name="Concept 6">
                    <span class="concept-name">Computationally secure:</span>
                    <span class="concept-description">The system is considered secure if the best possible algorithm to attack it requires a prohibitively large number of computations.</span>
                </div>
                <div class="concept-item" data-name="Concept 7">
                    <span class="concept-name">Clock-controlled shift register key stream generator:</span>
                    <span class="concept-description">Combines multiple smaller LFSRs to generate a significantly longer pseudo-random key stream z<sub>i</sub>. Types include stop-and-go, alternating step, and shrinking.</span>
                </div>
                <div class="concept-item" data-name="Concept 8">
                    <span class="concept-name">Chinese Remainder Theorem:</span>
                    <span class="concept-description">Reduces the complexity of exponentiation by employing smaller sized operands. Assume M = m<sub>1</sub>*m<sub>2</sub>*m<sub>3</sub>*...*m<sub>t</sub> where all m<sub>i</sub> are pairwise relatively prime. Given vectors x<sub>i</sub> = X (mod m<sub>i</sub>), X mod M can be uniquely reconstructed.</span>
                </div>
                <div class="concept-item" data-name="Concept 9">
                    <span class="concept-name">Cyclic group:</span>
                    <span class="concept-description">A finite group G containing element alpha with max order, alpha being called a generator of G. The number of generators in G is phi(|G|). For every element a in G, a<sup>|G|</sup> = 1, and the order of a evenly divides |G|.</span>
                </div>
            </div>

            <!-- D Section -->
            <div class="concept-section">
                <h2 class="section-title">D:</h2>
                <div class="concept-item" data-name="DES">
                    <span class="concept-name">DES:</span>
                    <span class="concept-description">Symmetric, 56-bit key length. Encrypts data in 64-bit blocks, performs 16 rounds of encryption using a Feistel network structure, has become less secure over time due to advances in computing power.</span>
                </div>
                <div class="concept-item" data-name="DES-PCBC">
                    <span class="concept-name">DES-PCBC mode:</span>
                    <span class="concept-description"> propagating cipher block chaining.A modified version of CBC mode, designed to propagate errors in multiple output blocks of the ciphertext.</span>
                </div>
                <div class="concept-item" data-name="DES-CFB">
                    <span class="concept-name">DES-CFB (cipher feedback) mode:</span>
                    <span class="concept-description">Used as a pseudo-random number generator. Generates a key stream z<sub>i</sub>.</span>
                </div>
                <div class="concept-item" data-name="DES-OFB">
                    <span class="concept-name">DES-OFB (output feedback) mode:</span>
                    <span class="concept-description">Similar to CFB. The shift register is loaded with block cipher output. The block cipher is used as a true synchronous stream cipher (the key stream no longer depends on the plaintext x<sub>i</sub>).</span>
                </div>
                <div class="concept-item" data-name="DES-CTR">
                    <span class="concept-name">DES-CTR (counter) mode:</span>
                    <span class="concept-description">Similar to CFB. Uses a block cipher as pseudo-random number generator, which does not require past ciphertext values to encrypt the current input to the block cipher. Allows for simultaneous processing of multiple input blocks. Typically used in ATM applications. Uses LFSR (loaded with IV) of the same size as the block cipher to generate block cipher input.</span>
                </div>
                <div class="concept-item" data-name="Differential Cryptanalysis attack">
                    <span class="concept-name">Differential Cryptanalysis attack:</span>
                    <span class="concept-description">Could be chosen-plaintext attack, known-plaintext attack, or ciphertext-only attack. For chosen-plaintext attack, attacker chooses plaintext x<sub>1</sub> and x<sub>2</sub> and observes the resultant ciphertext y<sub>1</sub> and y<sub>2</sub>. Then computes delta x = x<sub>1</sub> XOR x<sub>2</sub> and delta y = y<sub>1</sub> XOR y<sub>2</sub>, which termed a differential. Then use statistical analysis to find which keys are more probable.</span>
                </div>
                <div class="concept-item" data-name="Discrete logarithm problem">
                    <span class="concept-name">Discrete logarithm problem:</span>
                    <span class="concept-description">Given G (a cyclic group based on set Z<sub>p*</sub>, the operation is multiplication), alpha (generator), and beta = alpha<sup>i</sup> (mod p), find i = log<sub>alpha</sub>beta (mod p).</span>
                </div>
                <div class="concept-item" data-name="Diffie-Hellman Key Agreement Protocol">
                    <span class="concept-name">Diffie-Hellman Key Agreement Protocol:</span>
                    <span class="concept-description">May be used in discrete logarithm problem. Two stages: set-up and key establishment. <strong>Set-up:</strong> Choose a large p (typically implemented via Monte Carlo algorithm). Then choose a generator alpha in Z<sub>p*</sub>; p and alpha are public known. <strong>Key establishment:</strong> Establish a shared secret between 2 parties. Public keys are K<sub>PUB_A</sub> = b<sub>A</sub> = alpha(x)<sup>a<sub>A</sub></sup> (mod P(x)), K<sub>PUB_B</sub> = b<sub>B</sub> = alpha(x)<sup>a<sub>B</sub></sup> (mod P(x)) where x is plaintext, P(x) is irreducible polynomial, a<sub>A</sub> and a<sub>B</sub> are private keys. And the session key is K<sub>AB</sub> = alpha(x)<sup>a<sub>A</sub> b<sub>B</sub></sup>. After key establishment stage, the session key K<sub>AB</sub> is shared. So the Diffie-Hellman problem states that given alpha, b<sub>A</sub> = alpha(x)<sup>a<sub>A</sub></sup> (mod p), b<sub>B</sub> = alpha(x)<sup>a<sub>B</sub></sup> (mod p), find alpha<sup>a<sub>A</sub> a<sub>B</sub></sup> (mod p). One method is to solve one of the discrete logarithm problems for either a<sub>A</sub> = log<sub>alpha</sub>b<sub>A</sub> (mod p) or a<sub>B</sub> = log<sub>alpha</sub>b<sub>B</sub> (mod p). Once either a<sub>A</sub> or a<sub>B</sub> is known, alpha<sup>a<sub>A</sub> a<sub>B</sub></sup> (mod p) = (b<sub>B</sub>)<sup>a<sub>A</sub></sup> (mod p) = (b<sub>A</sub>)<sup>a<sub>B</sub></sup> (mod p).</span>
                </div>
            </div>

            <!-- E Section -->
            <div class="concept-section">
                <h2 class="section-title">E:</h2>
                <div class="concept-item">
                    <span class="concept-name">Extension Field:</span>
                    <span class="concept-description">GF(p<sup>m</sup>). Extended by exponentiating the p by an integer m. Typically represented as polynomials with m coefficients, where each coefficient is an element of GF(p). Example: GF(2<sup>4</sup>) = a<sub>3</sub>x<sup>3</sup> + a<sub>2</sub>x<sup>2</sup> + a<sub>1</sub>x + a<sub>0</sub>, and each coefficient a<sub>i</sub> is an element of GF(2) = {0,1}.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Euclidean algorithm:</span>
                    <span class="concept-description">Compute the gcd(r<sub>0</sub>, r<sub>1</sub>) = r<sub>m</sub> in terms of r<sub>2</sub> and r<sub>3</sub>. Where r<sub>0</sub>, r<sub>1</sub>, r<sub>2</sub> are integers, and r<sub>0</sub> > r<sub>1</sub>, r<sub>2</sub> is the remainder.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Extended Euclidean algorithm:</span>
                    <span class="concept-description">Based on the theory that gcd(r<sub>0</sub>,r<sub>1</sub>) = r<sub>m</sub> = s*r<sub>0</sub> + t*r<sub>1</sub> where s and t are integers. Then s<sub>i</sub> = s<sub>i-2</sub> - q<sub>i-1</sub> * s<sub>i-1</sub> and t<sub>i</sub> = t<sub>i-2</sub> - q<sub>i-1</sub> * t<sub>i-1</sub> with initial conditions s<sub>0</sub> = 1, s<sub>1</sub> = 0, t<sub>0</sub> = 0, t<sub>1</sub> = 1. t value has to be in ring Z<sub>m</sub>.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Euler’s phi function:</span>
                    <span class="concept-description">Used to determine the number of integers in the ring Z<sub>m</sub> that are relatively prime to m. m can be represented by the product of prime numbers of the form m = P<sub>1</sub><sup>e<sub>1</sub></sup> * P<sub>2</sub><sup>e<sub>2</sub></sup> * … * P<sub>n</sub><sup>e<sub>n</sub></sup> where each P<sub>i</sub> is a different prime number and each e<sub>i</sub> is an integer.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Euler’s theorem:</span>
                    <span class="concept-description">If gcd(a,m) = 1, then a<sup>phi(m)</sup> = 1 mod m. Then a<sup>-1</sup> = a<sup>phi(m)-1</sup> mod m.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Exponentiation in RSA:</span>
                    <span class="concept-description">Repeated application of group operation, e.g., multiplication to an element x in the Ring Z<sub>n</sub>.</span>
                </div>          
            </div>

            <!-- F Section -->
            <div class="concept-section">
                <h2 class="section-title">F:</h2>
                <div class="concept-item">
                    <span class="concept-name">Feistel network:</span>
                    <span class="concept-description">A general method of transforming a function into a permutation. Basic Feistel network divides the data block into 2 halves, with one operating on the other. General Feistel network—for larger data blocks—performs a circular right shift (with same f-function) instead of swapping the halves. Requires multiple rounds to input all the sub-blocks to the f-function.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">f-function:</span>
                    <span class="concept-description">Uses one of the halves of the data block and a key to create a pseudo-random bit stream that is used to encrypt or decrypt the other half. Basic operations include XOR, AND, OR, Mod, shift, rotation, data-dependent rotation, multiplication in a Galois field, mod inversion, lookup table.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Field:</span>
                    <span class="concept-description">A ring (addition and multiplication) in which there exists an inverse for all elements except zero.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Finite field:</span>
                    <span class="concept-description">A field with a finite number of elements.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Fermat’s little theorem:</span>
                    <span class="concept-description">Extends Euler’s theorem when m is prime and denoted as p. Since &#x3C6;(p) = p-1, a<sup>p-1</sup> &#x2261; 1 (mod p). Then a<sup>-1</sup> &#x2261; a<sup>p-2</sup> (mod p). Can be also applied to nonzero element A(x) within GF(p<sup>m</sup>). A<sup>-1</sup>(x) &#x2261; A(x)<sup>p<sup>m-2</sup></sup> mod P(x).</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Finite group:</span>
                    <span class="concept-description">Denoted as G, has a finite number of elements g. Operation denoted as ○. The cardinality of the finite group G is the number of elements in G, denoted as |G| = g. Order of a in G is the smallest positive integer &theta; such that a○a○…○a = e. When G is formed by Z<sub>p</sub><sup>*</sup>, the max order of a is p - 1.</span>
                </div>           
            </div>

            <!-- G Section -->
            <div class="concept-section">
                <h2 class="section-title">G:</h2>
                <div class="concept-item">
                    <span class="concept-name">Galois Field:</span>
                    <span class="concept-description">A finite field GF(p) where all arithmetic in the field is performed modulo p (prime).</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Group:</span>
                    <span class="concept-description">A binary operation that has closure, associativity, identity, and inverse.</span>
                </div>
            </div>

            <!-- H Section -->
            <div class="concept-section">
                <h2 class="section-title">H:</h2>
                <!-- Add H concepts here -->
            </div>

            <!-- I Section -->
            <div class="concept-section">
                <h2 class="section-title">I:</h2>
                <div class="concept-item">
                    <span class="concept-name">IV (Initialization Vector):</span>
                    <span class="concept-description">A random string that is used as a third input in addition to the key and plaintext. AES-CBC IVs are always 128 bits long (16 bytes).</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Improved K-ary Method:</span>
                    <span class="concept-description">Computes and stores only the values of x raised to odd exponents. In the precomputation stage, values such as x<sup>1</sup>, x<sup>3</sup>, ..., x<sup>2<sup>k</sup>-1</sup> are generated and stored. X<sup>2</sup> is also generated and used. The exponentiation stage, similar to K-ary, begins with x<sup>e<sub>t-1</sub></sup> when e<sub>t-1</sub> is odd, already computed from the precomputation stage, operates the same as K-ary. When e<sub>j</sub> is even, x<sup>e<sub>j</sub></sup> is not available from the precomputation stage, but can be represented as e<sub>k-1</sub>e<sub>k-2</sub>…e<sub>h</sub>0…0 (with h trailing zeros and a non-zero bit pattern of length k-h bits, which must be odd).</span>
                </div>
            </div>

            <!-- J Section -->
            <div class="concept-section">
                <h2 class="section-title">J:</h2>
                <!-- Add J concepts here -->
            </div>

            <!-- K Section -->
            <div class="concept-section">
                <h2 class="section-title">K:</h2>
                <div class="concept-item">
                    <span class="concept-name">Known-Plaintext Attack:</span>
                    <span class="concept-description">Attacker knows some plaintext-ciphertext pairs (x<sub>1</sub>, y<sub>1</sub> = e<sub>k</sub>(x<sub>1</sub>)), (x<sub>2</sub>, y<sub>2</sub> = e<sub>k</sub>(x<sub>2</sub>)),…, and wants to know the key k.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Key Whitening:</span>
                    <span class="concept-description">Increases a block cipher’s security versus exhaustive key search attacks by increasing the key size without modifying the block cipher itself. Operates on the plaintext block prior to and following encryption.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Karatsuba-Ofman Multiplication Algorithm:</span>
                    <span class="concept-description">Let A(x) = a<sub>n-1</sub> * x<sup>n-1</sup> + … + a<sub>n/2</sub> * x<sup>n/2</sup> + a<sub>n/2 -1</sub> * x<sup>n/2 -1</sup> + … + a<sub>0</sub>. Rewrite A(x) as A<sub>h</sub>(x) + A<sub>l</sub>(x), where A<sub>h</sub>(x) represents the upper, and A<sub>l</sub>(x) the lower coefficients of A(x). Then A(x) = A<sub>h</sub>(x) * x<sup>n/2</sup> + A<sub>l</sub>(x), and similarly for B(x). Resulting in C(x) = A(x) * B(x) = A\<sub>h</sub>(x) * Bh(x) * x<sup>n</sup> + [A<sub>l</sub>(x) * B<sub>h</sub>(x) + A<sub>h</sub>(x) * B<sub>l</sub>(x)] * x<sup>n/2</sup> + A<sub>l</sub>(x) * B<sub>l</sub>(x).</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">K-ary Method:</span>
                    <span class="concept-description">An improvement of square-and-multiply algorithm, composed of two stages: precomputation and exponentiation. Precomputation stage generates and stores values x<sup>0</sup>, x<sup>1</sup>, x<sup>2</sup>, ..., x<sup>2<sup>k</sup>-1</sup>. Exponentiation stage evaluates i as a binary value in a grouping of k bits, denoted as e<sub>j</sub>, ranging from 0 to 2<sup>k</sup>-1, and builds x<sub>i</sub> interactively, beginning with the value x<sup>e<sub>t-1</sub></sup> where e<sub>t-1</sub> is the k most significant bits of i.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Feistel Network:</span>
                    <span class="concept-description">A general method of transforming a function into a permutation. Basic Feistel network divides the data block into 2 halves, one operating on the other. General Feistel network uses circular right shifts instead of swapping halves, requiring multiple rounds to input all sub-blocks to the f-function.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">f-Function:</span>
                    <span class="concept-description">Uses one of the halves of the data block and a key to create a pseudo-random bit stream, used to encrypt or decrypt the other half. Basic operations include XOR, AND, OR, Mod, shift, rotation, data-dependent rotation, multiplication in a Galois field, mod inversion, and lookup table.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Field:</span>
                    <span class="concept-description">A ring (addition and multiplication) in which an inverse exists for all elements except zero.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Finite Field:</span>
                    <span class="concept-description">A field with a finite number of elements.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Fermat’s Little Theorem:</span>
                    <span class="concept-description">Extends Euler’s theorem when m is prime (denoted as p). Since φ(p) = p-1, a<sup>p-1</sup> ≡ 1 (mod p). Then a<sup>-1</sup> = a<sup>p-2</sup> (mod p). Can be also applied to nonzero element A(x) within GF(p<sup>m</sup>). A<sup>-1</sup>(x) = A(x)<sup>p<sup>m</sup>-2</sup> (mod P(x)).</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Finite Group:</span>
                    <span class="concept-description">Denoted as G, has a finite number of elements g. Operation denoted as ○. The cardinality of the finite group G is the number of elements in G, denoted as |G| = g. The order of a in G is the smallest positive integer θ such that a○a○…○a = e. When G is formed by Z<sub>p</sub>*, the max order of a is p - 1.</span>
                </div>
            </div>

            <!-- L Section -->
            <div class="concept-section">
                <h2 class="section-title">L:</h2>
                <div class="concept-item">
                    <span class="concept-name">LFSR (Linear Feedback Shift Registers):</span>
                    <span class="concept-description">Used to generate key streams. m - number of flip flops; K<sub>i</sub> – elements stored in flip-flops; D<sub>i</sub> = Q<sub>i+1</sub>; C<sub>i</sub> – feedback coefficient controlling an on-off switch; Polynomial form: P(x) = x<sup>m</sup> + (c<sub>m-1</sub> * x<sup>m-1</sup>) + … + (c<sub>1</sub> * x) + c<sub>0</sub>.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Latticed-based post-quantum cryptography:</span>
                    <span class="concept-description">Bad basis as public key, good basis as private key, making it hard to solve the shortest/closest vector problem.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Learning with errors:</span>
                    <span class="concept-description">Used in RSA. Adds errors to the equations so that it’s difficult to find the plaintext without the private key (secret vector).</span>
                </div>
            </div>

            <!-- M Section -->
            <div class="concept-section">
                <h2 class="section-title">M:</h2>
                <div class="concept-item">
                    <span class="concept-name">MD5:</span>
                    <span class="concept-description">Message Digest algorithm that converts any length of document into a large number occupying a fixed amount of space (15 bytes).</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Miner:</span>
                    <span class="concept-description">In blockchain technology, a miner is awarded bitcoins for producing a new block, which is computationally difficult to generate.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Meet-in-the-middle Attack:</span>
                    <span class="concept-description">Used against multiple encryptions like DES by computing DES<sub>k_i</sub>(x<sub>0</sub>) = z<sub>i</sub> for all possible k<sub>i</sub>, storing each z<sub>i</sub> and associated k<sub>i</sub> in memory, and then checking if computed (DES<sub>k_j</sub>(y<sub>0</sub>))<sup>-1</sup> = z<sub>j</sub> matches any stored z<sub>i</sub> to find candidate key pairs.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">MAC Generation:</span>
                    <span class="concept-description">Once k<sub>1</sub> and k<sub>2</sub> are generated, divide message M into n blocks where n = [M/b], resulting in M = M<sub>1</sub> || M<sub>2</sub> || … || M<sub>n-1</sub> || M<sub>n</sub>*. If M<sub>n</sub>* is a complete block, M<sub>n</sub> = M<sub>n</sub>* XOR k<sub>1</sub>. If incomplete, it's padded. Using k and initial value C<sub>0</sub> = 0, C<sub>i</sub> = e<sub>k</sub>(C<sub>i-1</sub> XOR M<sub>i</sub>) is computed for each block to generate the MAC.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Montgomery Arithmetic:</span>
                    <span class="concept-description">Efficient method for modular arithmetic by transforming integers into an alternate domain where base10 division isn't needed. Defines the m-residue of an integer a as a˜ where a˜ = a * R (mod m), and R is the radix, thus avoiding division in its arithmetic operations.</span>
                </div>
            </div>

            <!-- N Section -->
            <div class="concept-section">
                <h2 class="section-title">N:</h2>
                <div class="concept-item">
                    <span class="concept-name">Nonce:</span>
                    <span class="concept-description">A random value that miners try to find to produce an acceptable hash.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">NFT (Non-Fungible Token):</span>
                    <span class="concept-description">Turns digital assets into unique ones by creating a digital signature that defines ownership, which can be bought or sold. Not interchangeable, each represents unique assets owned by a specific person. Contains distinguishable information, easily verifiable. Creates a blockchain-based digital certificate to give the work a unique identity.</span>
                </div>
            </div>

            <!-- O Section -->
            <div class="concept-section">
                <h2 class="section-title">O:</h2>
                <div class="concept-item">
                    <span class="concept-name">One-Time Pad:</span>
                    <span class="concept-description">X = {x₀, x₁, …} ∈ P; Y = {y₀, y₁, …} ∈ C; K = {k₀, k₁, …} ∈ K; x<sub>i</sub>, y<sub>i</sub>, k<sub>i</sub> ∈ {0,1}. Encryption: e<sub>k_i</sub>(x<sub>i</sub>) = (x<sub>i</sub> + k<sub>i</sub>) mod 2 = y<sub>i</sub>; Decryption: d<sub>k_i</sub>(y<sub>i</sub>) = (y<sub>i</sub> + k<sub>i</sub>) mod 2 = x<sub>i</sub>. Unconditionally secure if keys are used only once and are random.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">One-Way Function:</span>
                    <span class="concept-description">Its forward function is easy to compute but the inverse transformation is difficult to compute. Examples include integer factorization and discrete logarithm, often easier to compute when a trapdoor is open.</span>
                </div>
            </div>

            <!-- P Section -->
            <div class="concept-section">
                <h2 class="section-title">P:</h2>
                <div class="concept-item">
                    <span class="concept-name">Parameter Selection (in RSA):</span>
                    <span class="concept-description">The process of selecting p and q, typically via Monte Carlo algorithm (e.g., Miller-Rabin algorithm, faster than integer factorization). Selecting b via exponentiation algorithm. Selecting a via extended Euclidean algorithm or binary extended Euclidean algorithm.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Public-Key Algorithm:</span>
                    <span class="concept-description">Uses a public key for encryption and verification of digital signatures, and a private key for decryption and generating digital signatures.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Prime Field:</span>
                    <span class="concept-description">A field with a number of elements p that is a prime. Z<sub>p</sub> = {0,1,2, …, p-1}. An additive group over Z<sub>p</sub>. A multiplicative group over Z<sub>p</sub>* guarantees the existence of an inverse for all elements except zero.</span>
                </div>
            </div>

            <!-- Q Section -->
            <div class="concept-section">
                <h2 class="section-title">Q:</h2>
                <!-- Additional Q concepts can be listed here as needed -->
            </div>

            <!-- R Section -->
            <div class="concept-section">
                <h2 class="section-title">R:</h2>
                <div class="concept-item">
                    <span class="concept-name">RC4:</span>
                    <span class="concept-description">A stream cipher, key length ranges from 40 to 256 bits. Known for its simplicity but has several vulnerabilities. Previously used by SSL and WEP protocols.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Rijndael (AES):</span>
                    <span class="concept-description">Maps plaintext into a rectangular 4 x Nb array of bytes. Part of the AES standard.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">RSA:</span>
                    <span class="concept-description">Has two stages, setup and encryption/decryption. Setup involves selecting two large prime numbers, computing n = p*q, phi(n) = (p-1)(q-1), selecting b, and computing a = b<sup>-1</sup> mod phi(n). The public key is (n, b) and the private key is (p, q, a).</span>
                </div>
            </div>

            <!-- S Section -->
            <div class="concept-section">
                <h2 class="section-title">S:</h2>
                <div class="concept-item">
                    <span class="concept-name">Second-preimage resistance:</span>
                    <span class="concept-description">Even if one document producing a specific hash is known, it's still hard to find another document that produces the same hash.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Salt:</span>
                    <span class="concept-description">A publicly known value mixed with a user’s password before hashing to enhance security.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Stream ciphers:</span>
                    <span class="concept-description">Encrypt individual bits or bytes of plaintext directly as opposed to block ciphers that encrypt blocks of data.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Shannon’s properties for secure cryptosystems:</span>
                    <span class="concept-description">Includes confusion, obscuring the relationship between plaintext, ciphertext, and key; and diffusion, spreading the influence of one plaintext or key bit across many ciphertext bits to complicate attempts at decryption.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Square-and-Multiply algorithm:</span>
                    <span class="concept-description">An efficient method for exponentiation, evaluates the exponent bit by bit, squaring the base for each bit, and multiplying it by the base again if the bit is 1.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Sliding Window Method:</span>
                    <span class="concept-description">Improves the efficiency of the square-and-multiply algorithm by minimizing the number of multiplications required.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Semi-weak keys (for DES):</span>
                    <span class="concept-description">Identified 12 semi-weak keys (excluding the 4 weak keys). Encryption with one key is identical to decryption with the other. Results in all zeros, all ones, or patterns of alternating zeros and ones in C<sub>0</sub> and D<sub>0</sub> after PC-1. DES<sub>K_sw1</sub>(DES<sub>K_sw2</sub>(x)) = x.</span>
                </div>
                <div class="concept-item">
                    <span class="concept-name">Subgroup:</span>
                    <span class="concept-description">A subset of a cyclic group where the elements themselves form a cyclic group under the same operation. An element &delta; in a group G with order &theta; generates a subgroup that is a cyclic group with &theta; elements. &theta; evenly divides |G|.</span>
                </div>
            </div>
            
            <!-- T Section -->
            <div class="concept-section">
                <h2 class="section-title">T:</h2>
                <div class="concept-item">
                    <span class="concept-name">Twofish:</span>
                    <span class="concept-description">A symmetric block cipher that supports key lengths of 128, 192, or 256 bits. Utilizes a Feistel network structure, dividing the data into two halves and applying multiple encryption rounds. Known for strong security without significant vulnerabilities.</span>
                </div>
            </div>

            <!-- U Section -->
            <div class="concept-section">
                <h2 class="section-title">U:</h2>

            </div>

            <!-- V Section -->
            <div class="concept-section">
                <h2 class="section-title">V:</h2>

            </div>

            <!-- W Section -->
            <div class="concept-section">
                <h2 class="section-title">W:</h2>
                <div class="concept-item">
                    <span class="concept-name">Weak Keys (for DES):</span>
                    <span class="concept-description">Four identified keys cause the bits of C<sub>0</sub> and D<sub>0</sub> to be either all zeros or all ones after PC-1. DES<sub>K_w</sub>(DES<sub>K_w</sub>(x)) = x.</span>
                </div>
            </div>
            
            <!-- X Section -->
            <div class="concept-section">
                <h2 class="section-title">X:</h2>

            </div>

            <!-- Y Section -->
            <div class="concept-section">
                <h2 class="section-title">Y:</h2>

            </div>

            <!-- Z Section -->
            <div class="concept-section">
                <h2 class="section-title">Z:</h2>
                <div class="concept-item">
                    <span class="concept-name">Z<sub>n</sub>*:</span>
                    <span class="concept-description">The set of integers i, 0 &le; i &le; n, such that gcd(i, n) = 1.</span>
                </div>
            </div>

            <!-- # Section -->
            <div class="concept-section">
                <h2 class="section-title">#:</h2>
                <div class="concept-item">
                    <span class="concept-name">3DES:</span>
                    <span class="concept-description">Uses a 168-bit key derived from three 56-bit keys used sequentially. Encrypts data in 64-bit blocks by encrypting with the first key, decrypting with the second, and encrypting again with the third. Offers enhanced security over DES at the cost of reduced speed and efficiency due to triple encryption.</span>
                </div>
            </div>

  
    </div>
    <script src="\static\concepts.js"></script>
</body>
</html>
